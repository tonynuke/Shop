/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { ProblemDetails } from '@/modules/common/problem-details'
import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class IdentityClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param returnUrl (optional) 
     * @return Success
     */
    login(returnUrl: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Account/login?";
        if (returnUrl === null)
            throw new Error("The parameter 'returnUrl' cannot be null.");
        else if (returnUrl !== undefined)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createClient(body: CreateClientModel | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Clients";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateClient(_response);
        });
    }

    protected processCreateClient(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    getClient(clientId: string , cancelToken?: CancelToken | undefined): Promise<Client> {
        let url_ = this.baseUrl + "/Clients/{clientId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetClient(_response);
        });
    }

    protected processGetClient(response: AxiosResponse): Promise<Client> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Client.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Client>(<any>null);
    }

    /**
     * @param errorId (optional) 
     * @return Success
     */
    error(errorId: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Home/error?";
        if (errorId === null)
            throw new Error("The parameter 'errorId' cannot be null.");
        else if (errorId !== undefined)
            url_ += "errorId=" + encodeURIComponent("" + errorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processError(_response);
        });
    }

    protected processError(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    createApiResource(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Resources/api-resource";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateApiResource(_response);
        });
    }

    protected processCreateApiResource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createRole(body: CreateRoleModel | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Resources/create-role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRole(_response);
        });
    }

    protected processCreateRole(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param role (optional) 
     * @param type (optional) 
     * @param value (optional) 
     * @return Success
     */
    addClaimToRole(role: string | undefined, type: string | undefined, value: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Resources/add-claim-to-role?";
        if (role === null)
            throw new Error("The parameter 'role' cannot be null.");
        else if (role !== undefined)
            url_ += "role=" + encodeURIComponent("" + role) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (value === null)
            throw new Error("The parameter 'value' cannot be null.");
        else if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddClaimToRole(_response);
        });
    }

    protected processAddClaimToRole(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUserToRole(body: AddUserToRoleModel | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Resources/add-user-to-role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddUserToRole(_response);
        });
    }

    protected processAddUserToRole(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    signUp(body: SignUpModel | undefined , cancelToken?: CancelToken | undefined): Promise<UserModel> {
        let url_ = this.baseUrl + "/api/Users/sign-up";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignUp(_response);
        });
    }

    protected processSignUp(response: AxiosResponse): Promise<UserModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserModel.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    logIn(body: SignInModel | undefined , cancelToken?: CancelToken | undefined): Promise<UserModel> {
        let url_ = this.baseUrl + "/api/Users/log-in";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogIn(_response);
        });
    }

    protected processLogIn(response: AxiosResponse): Promise<UserModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserModel.fromJS(resultData200);
            return result200;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserModel>(<any>null);
    }

    /**
     * @return Success
     */
    logOut(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Users/log-out";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogOut(_response);
        });
    }

    protected processLogOut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export enum AccessTokenType {
    _0 = 0,
    _1 = 1,
}

export class AddUserToRoleModel implements IAddUserToRoleModel {
    userId?: string | undefined;
    role?: string | undefined;

    constructor(data?: IAddUserToRoleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): AddUserToRoleModel {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserToRoleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["role"] = this.role;
        return data; 
    }
}

export interface IAddUserToRoleModel {
    userId?: string | undefined;
    role?: string | undefined;
}

export class Client implements IClient {
    enabled?: boolean;
    clientId?: string | undefined;
    protocolType?: string | undefined;
    clientSecrets?: Secret[] | undefined;
    requireClientSecret?: boolean;
    clientName?: string | undefined;
    description?: string | undefined;
    clientUri?: string | undefined;
    logoUri?: string | undefined;
    requireConsent?: boolean;
    allowRememberConsent?: boolean;
    allowedGrantTypes?: string[] | undefined;
    requirePkce?: boolean;
    allowPlainTextPkce?: boolean;
    requireRequestObject?: boolean;
    allowAccessTokensViaBrowser?: boolean;
    redirectUris?: string[] | undefined;
    postLogoutRedirectUris?: string[] | undefined;
    frontChannelLogoutUri?: string | undefined;
    frontChannelLogoutSessionRequired?: boolean;
    backChannelLogoutUri?: string | undefined;
    backChannelLogoutSessionRequired?: boolean;
    allowOfflineAccess?: boolean;
    allowedScopes?: string[] | undefined;
    alwaysIncludeUserClaimsInIdToken?: boolean;
    identityTokenLifetime?: number;
    allowedIdentityTokenSigningAlgorithms?: string[] | undefined;
    accessTokenLifetime?: number;
    authorizationCodeLifetime?: number;
    absoluteRefreshTokenLifetime?: number;
    slidingRefreshTokenLifetime?: number;
    consentLifetime?: number | undefined;
    refreshTokenUsage?: TokenUsage;
    updateAccessTokenClaimsOnRefresh?: boolean;
    refreshTokenExpiration?: TokenExpiration;
    accessTokenType?: AccessTokenType;
    enableLocalLogin?: boolean;
    identityProviderRestrictions?: string[] | undefined;
    includeJwtId?: boolean;
    claims?: ClientClaim[] | undefined;
    alwaysSendClientClaims?: boolean;
    clientClaimsPrefix?: string | undefined;
    pairWiseSubjectSalt?: string | undefined;
    userSsoLifetime?: number | undefined;
    userCodeType?: string | undefined;
    deviceCodeLifetime?: number;
    allowedCorsOrigins?: string[] | undefined;
    properties?: { [key: string]: string; } | undefined;

    constructor(data?: IClient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enabled = _data["enabled"];
            this.clientId = _data["clientId"];
            this.protocolType = _data["protocolType"];
            if (Array.isArray(_data["clientSecrets"])) {
                this.clientSecrets = [] as any;
                for (let item of _data["clientSecrets"])
                    this.clientSecrets!.push(Secret.fromJS(item));
            }
            this.requireClientSecret = _data["requireClientSecret"];
            this.clientName = _data["clientName"];
            this.description = _data["description"];
            this.clientUri = _data["clientUri"];
            this.logoUri = _data["logoUri"];
            this.requireConsent = _data["requireConsent"];
            this.allowRememberConsent = _data["allowRememberConsent"];
            if (Array.isArray(_data["allowedGrantTypes"])) {
                this.allowedGrantTypes = [] as any;
                for (let item of _data["allowedGrantTypes"])
                    this.allowedGrantTypes!.push(item);
            }
            this.requirePkce = _data["requirePkce"];
            this.allowPlainTextPkce = _data["allowPlainTextPkce"];
            this.requireRequestObject = _data["requireRequestObject"];
            this.allowAccessTokensViaBrowser = _data["allowAccessTokensViaBrowser"];
            if (Array.isArray(_data["redirectUris"])) {
                this.redirectUris = [] as any;
                for (let item of _data["redirectUris"])
                    this.redirectUris!.push(item);
            }
            if (Array.isArray(_data["postLogoutRedirectUris"])) {
                this.postLogoutRedirectUris = [] as any;
                for (let item of _data["postLogoutRedirectUris"])
                    this.postLogoutRedirectUris!.push(item);
            }
            this.frontChannelLogoutUri = _data["frontChannelLogoutUri"];
            this.frontChannelLogoutSessionRequired = _data["frontChannelLogoutSessionRequired"];
            this.backChannelLogoutUri = _data["backChannelLogoutUri"];
            this.backChannelLogoutSessionRequired = _data["backChannelLogoutSessionRequired"];
            this.allowOfflineAccess = _data["allowOfflineAccess"];
            if (Array.isArray(_data["allowedScopes"])) {
                this.allowedScopes = [] as any;
                for (let item of _data["allowedScopes"])
                    this.allowedScopes!.push(item);
            }
            this.alwaysIncludeUserClaimsInIdToken = _data["alwaysIncludeUserClaimsInIdToken"];
            this.identityTokenLifetime = _data["identityTokenLifetime"];
            if (Array.isArray(_data["allowedIdentityTokenSigningAlgorithms"])) {
                this.allowedIdentityTokenSigningAlgorithms = [] as any;
                for (let item of _data["allowedIdentityTokenSigningAlgorithms"])
                    this.allowedIdentityTokenSigningAlgorithms!.push(item);
            }
            this.accessTokenLifetime = _data["accessTokenLifetime"];
            this.authorizationCodeLifetime = _data["authorizationCodeLifetime"];
            this.absoluteRefreshTokenLifetime = _data["absoluteRefreshTokenLifetime"];
            this.slidingRefreshTokenLifetime = _data["slidingRefreshTokenLifetime"];
            this.consentLifetime = _data["consentLifetime"];
            this.refreshTokenUsage = _data["refreshTokenUsage"];
            this.updateAccessTokenClaimsOnRefresh = _data["updateAccessTokenClaimsOnRefresh"];
            this.refreshTokenExpiration = _data["refreshTokenExpiration"];
            this.accessTokenType = _data["accessTokenType"];
            this.enableLocalLogin = _data["enableLocalLogin"];
            if (Array.isArray(_data["identityProviderRestrictions"])) {
                this.identityProviderRestrictions = [] as any;
                for (let item of _data["identityProviderRestrictions"])
                    this.identityProviderRestrictions!.push(item);
            }
            this.includeJwtId = _data["includeJwtId"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(ClientClaim.fromJS(item));
            }
            this.alwaysSendClientClaims = _data["alwaysSendClientClaims"];
            this.clientClaimsPrefix = _data["clientClaimsPrefix"];
            this.pairWiseSubjectSalt = _data["pairWiseSubjectSalt"];
            this.userSsoLifetime = _data["userSsoLifetime"];
            this.userCodeType = _data["userCodeType"];
            this.deviceCodeLifetime = _data["deviceCodeLifetime"];
            if (Array.isArray(_data["allowedCorsOrigins"])) {
                this.allowedCorsOrigins = [] as any;
                for (let item of _data["allowedCorsOrigins"])
                    this.allowedCorsOrigins!.push(item);
            }
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): Client {
        data = typeof data === 'object' ? data : {};
        let result = new Client();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        data["clientId"] = this.clientId;
        data["protocolType"] = this.protocolType;
        if (Array.isArray(this.clientSecrets)) {
            data["clientSecrets"] = [];
            for (let item of this.clientSecrets)
                data["clientSecrets"].push(item.toJSON());
        }
        data["requireClientSecret"] = this.requireClientSecret;
        data["clientName"] = this.clientName;
        data["description"] = this.description;
        data["clientUri"] = this.clientUri;
        data["logoUri"] = this.logoUri;
        data["requireConsent"] = this.requireConsent;
        data["allowRememberConsent"] = this.allowRememberConsent;
        if (Array.isArray(this.allowedGrantTypes)) {
            data["allowedGrantTypes"] = [];
            for (let item of this.allowedGrantTypes)
                data["allowedGrantTypes"].push(item);
        }
        data["requirePkce"] = this.requirePkce;
        data["allowPlainTextPkce"] = this.allowPlainTextPkce;
        data["requireRequestObject"] = this.requireRequestObject;
        data["allowAccessTokensViaBrowser"] = this.allowAccessTokensViaBrowser;
        if (Array.isArray(this.redirectUris)) {
            data["redirectUris"] = [];
            for (let item of this.redirectUris)
                data["redirectUris"].push(item);
        }
        if (Array.isArray(this.postLogoutRedirectUris)) {
            data["postLogoutRedirectUris"] = [];
            for (let item of this.postLogoutRedirectUris)
                data["postLogoutRedirectUris"].push(item);
        }
        data["frontChannelLogoutUri"] = this.frontChannelLogoutUri;
        data["frontChannelLogoutSessionRequired"] = this.frontChannelLogoutSessionRequired;
        data["backChannelLogoutUri"] = this.backChannelLogoutUri;
        data["backChannelLogoutSessionRequired"] = this.backChannelLogoutSessionRequired;
        data["allowOfflineAccess"] = this.allowOfflineAccess;
        if (Array.isArray(this.allowedScopes)) {
            data["allowedScopes"] = [];
            for (let item of this.allowedScopes)
                data["allowedScopes"].push(item);
        }
        data["alwaysIncludeUserClaimsInIdToken"] = this.alwaysIncludeUserClaimsInIdToken;
        data["identityTokenLifetime"] = this.identityTokenLifetime;
        if (Array.isArray(this.allowedIdentityTokenSigningAlgorithms)) {
            data["allowedIdentityTokenSigningAlgorithms"] = [];
            for (let item of this.allowedIdentityTokenSigningAlgorithms)
                data["allowedIdentityTokenSigningAlgorithms"].push(item);
        }
        data["accessTokenLifetime"] = this.accessTokenLifetime;
        data["authorizationCodeLifetime"] = this.authorizationCodeLifetime;
        data["absoluteRefreshTokenLifetime"] = this.absoluteRefreshTokenLifetime;
        data["slidingRefreshTokenLifetime"] = this.slidingRefreshTokenLifetime;
        data["consentLifetime"] = this.consentLifetime;
        data["refreshTokenUsage"] = this.refreshTokenUsage;
        data["updateAccessTokenClaimsOnRefresh"] = this.updateAccessTokenClaimsOnRefresh;
        data["refreshTokenExpiration"] = this.refreshTokenExpiration;
        data["accessTokenType"] = this.accessTokenType;
        data["enableLocalLogin"] = this.enableLocalLogin;
        if (Array.isArray(this.identityProviderRestrictions)) {
            data["identityProviderRestrictions"] = [];
            for (let item of this.identityProviderRestrictions)
                data["identityProviderRestrictions"].push(item);
        }
        data["includeJwtId"] = this.includeJwtId;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        data["alwaysSendClientClaims"] = this.alwaysSendClientClaims;
        data["clientClaimsPrefix"] = this.clientClaimsPrefix;
        data["pairWiseSubjectSalt"] = this.pairWiseSubjectSalt;
        data["userSsoLifetime"] = this.userSsoLifetime;
        data["userCodeType"] = this.userCodeType;
        data["deviceCodeLifetime"] = this.deviceCodeLifetime;
        if (Array.isArray(this.allowedCorsOrigins)) {
            data["allowedCorsOrigins"] = [];
            for (let item of this.allowedCorsOrigins)
                data["allowedCorsOrigins"].push(item);
        }
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key];
            }
        }
        return data; 
    }
}

export interface IClient {
    enabled?: boolean;
    clientId?: string | undefined;
    protocolType?: string | undefined;
    clientSecrets?: Secret[] | undefined;
    requireClientSecret?: boolean;
    clientName?: string | undefined;
    description?: string | undefined;
    clientUri?: string | undefined;
    logoUri?: string | undefined;
    requireConsent?: boolean;
    allowRememberConsent?: boolean;
    allowedGrantTypes?: string[] | undefined;
    requirePkce?: boolean;
    allowPlainTextPkce?: boolean;
    requireRequestObject?: boolean;
    allowAccessTokensViaBrowser?: boolean;
    redirectUris?: string[] | undefined;
    postLogoutRedirectUris?: string[] | undefined;
    frontChannelLogoutUri?: string | undefined;
    frontChannelLogoutSessionRequired?: boolean;
    backChannelLogoutUri?: string | undefined;
    backChannelLogoutSessionRequired?: boolean;
    allowOfflineAccess?: boolean;
    allowedScopes?: string[] | undefined;
    alwaysIncludeUserClaimsInIdToken?: boolean;
    identityTokenLifetime?: number;
    allowedIdentityTokenSigningAlgorithms?: string[] | undefined;
    accessTokenLifetime?: number;
    authorizationCodeLifetime?: number;
    absoluteRefreshTokenLifetime?: number;
    slidingRefreshTokenLifetime?: number;
    consentLifetime?: number | undefined;
    refreshTokenUsage?: TokenUsage;
    updateAccessTokenClaimsOnRefresh?: boolean;
    refreshTokenExpiration?: TokenExpiration;
    accessTokenType?: AccessTokenType;
    enableLocalLogin?: boolean;
    identityProviderRestrictions?: string[] | undefined;
    includeJwtId?: boolean;
    claims?: ClientClaim[] | undefined;
    alwaysSendClientClaims?: boolean;
    clientClaimsPrefix?: string | undefined;
    pairWiseSubjectSalt?: string | undefined;
    userSsoLifetime?: number | undefined;
    userCodeType?: string | undefined;
    deviceCodeLifetime?: number;
    allowedCorsOrigins?: string[] | undefined;
    properties?: { [key: string]: string; } | undefined;
}

export class ClientClaim implements IClientClaim {
    type?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;

    constructor(data?: IClientClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.value = _data["value"];
            this.valueType = _data["valueType"];
        }
    }

    static fromJS(data: any): ClientClaim {
        data = typeof data === 'object' ? data : {};
        let result = new ClientClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["value"] = this.value;
        data["valueType"] = this.valueType;
        return data; 
    }
}

export interface IClientClaim {
    type?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;
}

export class CreateClientModel implements ICreateClientModel {
    name?: string | undefined;
    scopes?: string[] | undefined;

    constructor(data?: ICreateClientModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateClientModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClientModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        return data; 
    }
}

export interface ICreateClientModel {
    name?: string | undefined;
    scopes?: string[] | undefined;
}

export class CreateRoleModel implements ICreateRoleModel {
    roleName?: string | undefined;

    constructor(data?: ICreateRoleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): CreateRoleModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleName"] = this.roleName;
        return data; 
    }
}

export interface ICreateRoleModel {
    roleName?: string | undefined;
}

export class Secret implements ISecret {
    description?: string | undefined;
    value?: string | undefined;
    expiration?: Date | undefined;
    type?: string | undefined;

    constructor(data?: ISecret) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.value = _data["value"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): Secret {
        data = typeof data === 'object' ? data : {};
        let result = new Secret();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["value"] = this.value;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["type"] = this.type;
        return data; 
    }
}

export interface ISecret {
    description?: string | undefined;
    value?: string | undefined;
    expiration?: Date | undefined;
    type?: string | undefined;
}

export class SignInModel implements ISignInModel {
    email!: string;
    password!: string;

    constructor(data?: ISignInModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): SignInModel {
        data = typeof data === 'object' ? data : {};
        let result = new SignInModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data; 
    }
}

export interface ISignInModel {
    email: string;
    password: string;
}

export class SignUpModel implements ISignUpModel {
    email!: string;
    password!: string;

    constructor(data?: ISignUpModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): SignUpModel {
        data = typeof data === 'object' ? data : {};
        let result = new SignUpModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data; 
    }
}

export interface ISignUpModel {
    email: string;
    password: string;
}

export enum TokenExpiration {
    _0 = 0,
    _1 = 1,
}

export enum TokenUsage {
    _0 = 0,
    _1 = 1,
}

export class UserModel implements IUserModel {
    id?: string | undefined;
    name?: string | undefined;
    token?: string | undefined;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["token"] = this.token;
        return data; 
    }
}

export interface IUserModel {
    id?: string | undefined;
    name?: string | undefined;
    token?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}